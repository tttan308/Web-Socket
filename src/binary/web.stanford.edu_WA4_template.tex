\documentclass[11pt]{article}
\usepackage[pdftex]{graphicx, color}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{ebproof}

\newcommand\tab[1][1cm]{\hspace*{#1}}
\usepackage{array}
\newcommand{\PreserveBackslash}[1]{\let\temp=\\#1\let\\=\temp}
\newcolumntype{C}[1]{>{\PreserveBackslash\centering}p{#1}}
\newcolumntype{R}[1]{>{\PreserveBackslash\raggedleft}p{#1}}
\newcolumntype{L}[1]{>{\PreserveBackslash\raggedright}p{#1}}
%% \newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
%% \newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
%% \newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\usepackage{tikz}
\usetikzlibrary{graphs}
\usetikzlibrary{automata,positioning}

\let\epsilon\varepsilon
\tikzset{shorten >=1pt, node distance=2cm, on grid, baseline={([yshift=-8pt] current bounding box.north)}}

\headheight 8pt \headsep 20pt \footskip 30pt
\textheight 9in \textwidth 6.5in
\oddsidemargin 0in \evensidemargin 0in
\topmargin -.35in

\lstset{basicstyle=\small\ttfamily,breaklines=true,numbers=left}
\lstset{escapeinside={<@}{@>}}
\newcommand{\code}[1]{\lstinline{#1}}

\begin{document}
\begin{center}
\LARGE YOURNAME -- SUNETID \\
\LARGE CS143 Spring 2022 -- Written Assignment 4 \\
\end{center}

This assignment covers code generation, operational semantics, and optimization. You may discuss this assignment with other students and work on the problems together. However, your write-up should be your own individual work, and you should indicate in your submission who you worked with, if applicable. Assignments can be submitted electronically through Gradescope as a PDF by Tuesday, May 31, 2022 at 11:59 PM PDT. A \LaTeX \ template for writing your solutions is available on the course website.

\bigskip

\begin{enumerate}
% Problem 1
\item Consider the following program in Cool, representing a ``slightly'' over-engineered implementation which calculates the sum of $\{0,1,2\}$
  using an operator class and a reduce() method:
\begin{lstlisting}
class BinOp {
    optype(): String {
        "BinOp"
    };

    operate(a: Int, b: Int): Int {
        a + b
    };
};

class SumOp inherits BinOp {
    optype(): String {
        "SumOp"
    };
};

class MulOp inherits BinOp {
    optype(): String {
        "MulOp"
    };

    operate(a: Int, b: Int): Int {
        a * b
    };
};

class IntList {
    head: Int;
    tail: IntList;
    empty_tail: IntList; -- Do not assign.

    tail_is_empty(): Bool {
        tail = empty_tail
    };

    get_head(): Int { head };

    set_head(n: Int): Int {
        head <- n
    };

    get_tail(): IntList { tail };

    set_tail(t: IntList): IntList {
        tail <- t
    };

    generate(n: Int): IntList {
        let l: IntList <- New IntList in {
            l.set_head(n);
            -- Point A
            if (n = 1) then
                l.set_tail(empty_tail)
            else
                l.set_tail(generate(n-1))
            fi;
            l;
        }
    };
};

class Main {
    reduce(result: Int, op: BinOp, l: IntList): Int {{
        result <- op.operate(result,l.get_head());
        if (l.tail_is_empty() = true) then
            -- Point B
            result
        else
            reduce(result,op,l.get_tail())
        fi;
    }};

    main(): Object {
        let op: BinOp <- new SumOp, l: IntList <- new IntList,
            io: IO <- new IO in {
            l <- l.generate(2);
            io.out_int(self.reduce(0,op,l));
        }
    };
};
\end{lstlisting}

\newpage

The following is an abstracted representation of a memory layout of the program generated by a hypothetical Cool compiler for the above code (note that this might or might not correspond to the layout generated by your compiler or the reference coolc):

\begin{tabular}{ | c | }
\hline 
\textbf{Code segment:} \\ 
\begin{tabular}{ | R{2cm} | L{9cm} |}
\hline
$\mathtt{maddr}_1$: & \texttt{cgen\_m(BinOp.optype)} \\
\cline{2-2}
$\mathtt{maddr}_2$: & \texttt{cgen\_m(BinOp.operate)} \\
\cline{2-2}
$\mathtt{maddr}_3$: & \texttt{cgen\_m(SumOp.optype)} \\
\cline{2-2}
$\mathtt{maddr}_4$: & \texttt{cgen\_m(MulOp.optype)} \\
\cline{2-2}
$\mathtt{maddr}_5$: & \texttt{cgen\_m(MulOp.operate)} \\
\cline{2-2}
$\mathtt{maddr}_6$: & \texttt{cgen\_m(IntList.tail\_is\_empty)} \\
\cline{2-2}
$\mathtt{maddr}_7$: & \texttt{cgen\_m(IntList.get\_head)} \\
\cline{2-2}
$\mathtt{maddr}_8$: & \texttt{cgen\_m(IntList.set\_head)} \\
\cline{2-2}
$\mathtt{maddr}_9$: & \texttt{cgen\_m(IntList.get\_tail)} \\
\cline{2-2}
$\mathtt{maddr}_{10}$: & \texttt{cgen\_m(IntList.set\_tail)} \\
\cline{2-2}
$\mathtt{maddr}_{11}$: & \texttt{cgen\_m(IntList.generate)} \\
\cline{2-2}
$\mathtt{maddr}_{12}$: & \texttt{cgen\_m(Main.reduce)} \\
\cline{2-2}
$\mathtt{maddr}_{13}$: & \texttt{cgen\_m(Main.main)} \\
\hline
\end{tabular} \\
\textbf{Dispatch tables:} \\
\begin{tabular}{ | R{2cm} | L{9cm} |}
\hline
$\mathtt{maddr}_{14}$: & \texttt{DT[BinOp]} \\
\cline{2-2}
$\mathtt{maddr}_{15}$: & \texttt{DT[SumOp]} \\
\cline{2-2}
$\mathtt{maddr}_{16}$: & \texttt{DT[MulOp]} \\
\cline{2-2}
$\mathtt{maddr}_{17}$: & \texttt{DT[IntList]} \\
\cline{2-2}
$\mathtt{maddr}_{18}$: & \texttt{DT[Main]} \\
\hline
\end{tabular} \\
\\ \hline 
\textbf{Stack} ($\mathtt{maddr}_{19}$) \textit{(high address)} \\
$\downarrow$ \\
\\
\\
\\
\hline
\\
\\
\\
$\uparrow$ \\
\textbf{Heap} \textit{(low address)} \\
\hline 
\end{tabular}

In the above, $\mathtt{maddr}_i$ represents the memory address at which the corresponding method's code or dispatch table starts. You should assume that the above layout is contiguous in memory. Note that the stack starts at a high address and grows towards lower addresses.
\newpage
\begin{enumerate}
    \item  The following is a representation of the dispatch table for class Main: \\
    \newcommand{\dentry}[3]{#1 & \code{#2} & $\mathtt{maddr}_{#3}$ \\ \hline}

    \begin{tabular}{ | l | l | l | }
    \hline
    Method Idx & Method Name & Address \\
    \hline
    \dentry{0}{reduce}{12}
    \dentry{1}{main}{13}
    \end{tabular} \\

    Provide equivalent representations for the dispatch tables of BinOp, SumOp, MulOp, and IntList.
    Assume that the Object class has no methods.
    \\

    \textbf{Solution:}
    
    BinOp:\\
    \begin{tabular}{ | l | l | l | }
    \hline
    Method Idx & Method Name & Address \\
    \hline
    \end{tabular} \\

    SumOp:\\
    \begin{tabular}{ | l | l | l | }
    \hline
    Method Idx & Method Name & Address \\
    \hline
    \end{tabular} \\

    MulOp:\\
    \begin{tabular}{ | l | l | l | }
    \hline
    Method Idx & Method Name & Address \\
    \hline
    \end{tabular} \\

    IntList:\\
    \begin{tabular}{ | l | l | l | }
    \hline
    Method Idx & Method Name & Address \\
    \hline
    \end{tabular} \\

  \item  Consider the state of the program at runtime when reaching (for the first time) the line marked with the comment ``Point A''.
    Give the object layout (as per Lecture 12) of every object currently on the heap which is of a class defined by the program
    (i.e., ignoring Cool base classes such as IO or Int).
    
    For attributes, you can directly represent Int values by integers and an unassigned pointer by \textbf{void}.
    However, note that in a real Cool program, Int is an object and would have its own object layout, omitted here for simplicity.
    Finally, you can assume class tags are numbers from 1 to 5 given in the same order as the one in which classes appear in the layout above,
    and that attributes are laid out in the same order as the class definition.
    \\

    \textbf{Solution:}
    

    \newpage
  \item  The following table represents an abstract view of the layout of the stack at runtime when reaching (for the first time) the line marked with the comment ``Point A'':\\[0.5em]
    \newcommand{\mentry}[3]{$\mathtt{maddr}_{19}-#1$ & \code{Main.main} & #2 & #3 \\ \hline }
    \newcommand{\ientry}[3]{$\mathtt{maddr}_{19}-#1$ & \code{IntList.generate} & #2 & #3 \\ \hline }
    \begin{tabular}{ | r | l | c | l | }
        \hline
        Address & Method & Contents & Description \\
        \hline
        $\mathtt{maddr}_{19}$ & \code{Main.main} & self & $\mbox{arg}_0$ \\
        \hline
        \mentry{4}{...}{Return}
        \mentry{8}{op}{local}
        \mentry{12}{l}{local}
        \mentry{16}{io}{local}
        \ientry{20}{$\mathtt{maddr}_{19}-4$}{FP}
        \ientry{24}{2}{$\text{arg}_1$}
        \ientry{28}{self}{$\text{arg}_0$}
        \ientry{32}{$\mathtt{maddr}_{13}+\delta$}{Return}
        \ientry{36}{l}{local}
    \end{tabular} \\

    Assume that the activation record  is set as in Lecture 12 (e.g., slide 20).
    Note that we are assuming there are no stack frames above Main.main(...). This doesn't necessarily match a real implementation of the Cool runtime system, where main must return control to the OS or the Cool runtime on exit. For the purposes of this exercise, feel free to ignore this issue.
    \\[0.5em]
    Since you don't have the generated code for every method above, you cannot directly calculate the return address to be stored on the stack. You should however give it as $\mathtt{maddr}_{i}+\delta$, denoting an unknown address between $\mathtt{maddr}_{i}$ and $\mathtt{maddr}_{i+1}$. This notation is used in the example above. For locals, you should use the variable name, but remember that in practice it is the heap address that gets stored in memory for objects.
    \\[0.5em]
    Give a similar view of the stack at runtime when reaching (for the first time) the line marked with the comment ``Point B''.
    \\[0.5em]
    \textbf{Solution:}
    
    \newcommand{\rentry}[3]{$\mathtt{maddr}_{19}-#1$ & \code{Main.reduce} & #2 & #3 \\ \hline }
    \begin{tabular}{ | r | l | c | l | }
        \hline
        Address & Method & Contents & Description \\
        \hline
    \end{tabular}
\end{enumerate}
\newpage

  % Problem 2 
  \item  Consider the following arithmetic expression: $(1+(2*3-8/4)) + (5-6)*7$.
  
  \begin{enumerate}
    \item  You are given MIPS code that evaluates this expression using a stack machine with a single accumulator register (similar to the method given in class Lecture 12). This code is wholly unoptimized and will execute the operations given in the expression above in their original order (e.g., it does not perform transformations such as arithmetic simplification or constant folding). How many times in total will this code push a value to or pop a value from the stack? Give a separate count for the number of pushes and the number of pops.
    \\
      
    \textbf{Solution:}
    
    
    \item  You are now given MIPS code that evaluates the same expression using a register machine with only 2 registers. Again, this code includes no optimizations and will perform every operation in the original expression, in the same order. How many loads from and stores to memory will this code perform, at a minimum?  Give a separate count for loads and for stores.
      \\
      
      \textbf{Solution:} 

  \end{enumerate}
\newpage

  % Problem 3 
  \item  Suppose you want to add a for-loop construct to Cool, having the following syntax:
  $$\mbox{for}\  e_1\ \mbox{to}\ e_2\ \mbox{do}\ e_3\ \mbox{rof}$$ 
    The above for-loop expression is evaluated as follows:
    $e_1$ is evaluated first, $e_2$ is evaluated next,
    and then the body of the loop ($e_3$) is executed once for every integer in the range $[e_1,e_2]$ (inclusive) in increasing order.
    Here $e_1$ and $e_2$ should be evaluated only once.
    Similar to the while loop, the for-loop returns void.
  
   \begin{enumerate}
    \item  Give the operational semantics for the for-loop construct above.
    
    \textbf{Solution:}
    
  \item  Give the code generation function $\mbox{cgen}(\mbox{for}\ e_1\ \mbox{to}\ e_2\ \mbox{do}\ e_3\ \mbox{rof})$ for this construct. Use the code generation conventions from the lecture. The result of $\mbox{cgen}(...)$ must be MIPS code following the stack-machine with one accumulator model.
    
    Assume that cgen($e_1$) (and similarly cgen($e_2$)) does integer unboxing, i.e.,
    the evaluation result of $e_1$ will be stored in \texttt{\$a0} after executing cgen($e_1$).
    You can use the instruction {\tt ble r1, r2, label}
    in order to branch to {\tt label} if $\texttt{r1} \leq \texttt{r2}$.
    
      \textbf{Solution:}
    
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
    cgen(for e1 to e2 do e3 rof) =
    \end{lstlisting}
    
   \end{enumerate}
\newpage


  % Problem 4
  \item  Consider the following basic block, in which all variables are integers.
  
  \begin{lstlisting}
    a := f / 1
    b := f * g
    c := b + b
    d := a - 3
    x := a * g
    y := x + x
    z := y * c
  \end{lstlisting}

  \begin{enumerate}
  \item
  Assume that the only variable that is live at the exit of this block is {\tt z}, while {\tt f} and {\tt g} are given as inputs. In order, apply the following optimizations to this basic block. Show the result of each transformation. For each optimization, you must continue to apply it until no further applications of that transformation are possible, before writing out the result and moving on to the next.
  Assume that {\tt +} is faster than {\tt *} and {\tt <<}.
  
  \begin{enumerate}
    \item Algebraic simplification
    \item Copy propagation
    \item Common sub-expression elimination
    \item Copy propagation
    \item Dead code elimination
  \end{enumerate}

    \textbf{Solution:} 
    


\item
  The resulting program is still not optimal. What optimizations, in what order, can you apply to fully optimize the result? Show the maximally optimized codes (with least number of instructions).
  \\
    
    \textbf{Solution:} 
  \end{enumerate}
    
    
    \newpage

% Problem 5
  \item  Consider the following assembly-like pseudo-code, using 11 temporaries (abstract registers) \texttt{t0} to \texttt{t10}: 
  
  \begin{lstlisting}
    t1 := t0 * t0
    t2 := -t1
    t3 := t2 + t0
    if t3 > 0:
        t4 := t0 - t3
        t5 := t2 * 3
        t6 := t4 - t5
    else:
        t7 := t0 + t3
        t8 := t2 * 3
        t6 := t7 + t8
    t9 := t0 * t3
    t10 := t6 + t9
  \end{lstlisting}

\begin{enumerate}
    \item At each program point, list the variables that are live. Note that \texttt{t0} is the only input for the given code and \texttt{t10} is the only live value on exit.

    \textbf{Solution:}


    \item Draw the register interference graph between temporaries in the above program as described in class.

    \textbf{Solution:}

    \item Provide a lower bound on the number of registers required by the program that does not involve spilling, based on (a) or (b). Can you explain why?

    \textbf{Solution:}

  \item Using the algorithm described in class, provide a coloring of the graph in (b).
    The number of colors used should be your lower bound in (c).
    Provide the final k-colored graph (you may use the tikz package to typeset it or simply embed an image),
    along with the order in which the algorithm colors the nodes.

    \textbf{Solution:}
    \item Based on your coloring, write down a mapping from temporaries to registers (labeled {\tt r0}, {\tt r1}, etc.).

    \textbf{Solution:} 
      
\end{enumerate}

\end{enumerate}
\end{document}
